---
layout: post
title: "[SPRINGBOOT] 회원 관리 예제"
date: 2024-08-31
tags: [SPRINGBOOT]
categories: SPRINGBOOT
---

### 인텔리제이 단축키 참고

key map 기준이 어떤 프로그램으로 되어 있는지 꼭 확인할 것!

---

## 1. 백엔드 개발

### 일반적인 웹 애플리케이션 계층 구조

- 컨트롤러 : 웹 MVC의 컨트롤러 역할
- 서비스 : 핵심 비즈니스 로직 구현
- 리포지토리 : 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리
- 도메인 : 비즈니스 도메인 객체, 예) 회원, 주문, 쿠폰 등등 주로 데이터베이스에 저장하고 관리됨

### 회원 리포지토리 테스트 케이스 작성

- @AfterEach : 한번에 여러 테스트를 실행하면 메모리 DB에 직전 테스트의 결과가 남을 수 있음, 각 테스트가 종료될 때마다 메모리 DB에 저장된 데이터 삭제
- @BeforeEach : 각 테스트 실행 전에 호출, 테스트가 서로 영향이 없도록 항상 새로운 객체 생성, 의존관계도 새로 맺어줌

---

## 2. 스프링 빈과 의존관계

### 스프링 빈(Bean)

- 빈(Bean) : 스프링 컨테이너에 의해 관리되는 재사용 가능한 소프트웨어 컴포넌트  
  즉, 스프링 컨테이너가 관리하는 자바 객체를 뜻하며 하나 이상의 빈(Bean)을 관리

> *사용이유* : 스프링 간 객체가 의존관계를 관리하도록 하는 것에 가장 큰 목적이 있음, 객체가 의존관계를 등록할 때 스프링 컨테이너에서 해당하는 빈을 찾고, 그 빈과 의존성을 만듬

### 회원 컨트롤러에 의존관계 추가

- 생성자에 @Autowired가 있으면 스프링이 연관된 객체를 스프링 컨테이너에 찾아서 넣어줌
  - 객체 의존관계를 외부에서 넣어주는 것을 DI(Dependency Injection), 의존성 주입이라 함

### 컴포넌트 스캔 원리

- @Component 애노테이션이 있으면 스프링 빈으로 자동 등록
- @Controller 컨트롤러가 스프링 빈으로 자동 등록된 이유도 컴포넌트 스캔 때문
- @Component 포함하는 애노테이션
  - @Controller, @Service, @Repository

#### [회원 서비스 스프링 빈 등록]

> *참고* : 생성자에 @Autowired를 사용하면 객체 생성 시점에 스프링 컨테이너에서 해당 스프링 빈을 찾아서 주입, 생성자 1개만 있으면 생략 가능

### 자바 코드로 직접 스프링 빈 등록

> *참고* : DI에는 필드 주입, setter 주입, 생성자 주입 이렇게 3가지 방법이 있으며, 의존관계가 실행중에 동적으로 변하는 경우는 거의 없으므로 생성자 주입을 권장

---

## 3. 스프링 DB 접근 기술

### 스프링 통합 테스트

#### [H2 데이터베이스 설치]

https://www.h2database.com/html/main.html

- 설치 진행 후 cmd에서 해당 폴더 위치로 이동

- h2>bin 위치에서 'h2.bat'

- 데이터베이스 파일 생성 방법
  - jdbc:hw:~/test (최초 한번)
  - ~/test.mv.db 파일 생성 확인
  - jdbc:h2:tcp://localhost/~/test 접속

#### [테이블 생성하기]

```java
drop table if exists member CASCADE;
create table member
(
  id bigint generated by default as identity,
  name varchar(255),
  primary key (id)
);
```

#### [순수 Jdbc]

build.gradle 파일에 라이브러리 추가(**Reload 필수)

```java
implementation 'org.springframework.boot:spring-boot-starter-jdbc'
runtimeOnly 'com.h2database:h2'
```

application.properties 파일에 데이터베이스 연결 설정 추가

```java
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
```

> *오류* : DataSourceUtils 오류 표시 발생

- build.gradle 파일 라이브러리 추가 및 리로드 진행 후 해결

#### [회원 서비스 스프링 통합 테스트]

> *오류*   
> 1. h2 데이터베이스와 연동이 안됨
> 2. 테스트 진행 시 DB 업로드 오류

1. h2 'test.mv.db' 파일 제거 후 재생성(**h2 설치 참고)

2. @Transactional : 테스트 케이스에 이 애노테이션이 있으면, 테스트 완료 후 항상 롤백하므로 DB에 데이터가 남지 않음, 다음 테스트에 영향을 주지 않아 반복 테스트 가능   
** 확인 진행 시, @Commit 애노테이션 추가 또는 @Transactional 제거

### JPA

- JPA는 기존의 반복 코드는 물론, 기본적인 SQL도 JPA가 직접 만들어서 실행해줌
- 개발 생산성을 크게 높여줌

#### [라이브러리 추가]

```java
dependencies {
  // implementation 'org.springframework.boot:spring-boot-starter-jdbc'
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
}
```
- jdbc도 jpa에 포함되어 있어 제거 가능

#### [JPA 설정 추가]

```java
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
```
- show-sql : JPA가 생성하는 SQL 출력
- ddl-auto : JPA는 테이블을 자동으로 생성하는 기능 제공, none - 해당 기능 OFF
  - create를 사용하면 엔티티 정보를 바탕으로 테이블도 직접 생성

#### [서비스 계층에 트랜잭션 추가]

```java
@Transactional
public class MemberService {}
```
- 스프링은 해당 클래스의 메서드를 실행할 때 트랜잭션을 시작하고, 메서드가 정상 종료되면 트랜잭션을 커밋(런타임 예외 발생 시 롤백)
- JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행

### 스프링 데이터 JPA

- 개발 생산성 증가
- 인터페이스 만으로 개발 완료 가능
- 반복 개발해온 기본 CRUD 기능도 스프링 데이터 JPA가 모두 제공

> *오류* : 순서대로 파일 코드 변경 후 통합테스트 오류 발생 (java.lang.IllegalStateException: Failed to load ApplicationContext)

- 'MemoryMemberRepository' 파일에서 @Repository 어노테이션 삭제 후 정상 진행
  - 동일한 타입(MemberRepository)의 빈을 2개 등록해서 발생하는 문제
  - @Repository로 자동 빈 등록(컴포넌트 스캔의 대상)을 삭제 하여 해결이 된 것

---
